<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Reconstruction Calls &#8212; Monalisa 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="_static/custom-navigation.css?v=899df2ba" />
    <link rel="stylesheet" type="text/css" href="_static/custom-button.css?v=35775deb" />
    <link rel="stylesheet" type="text/css" href="_static/important.css?v=8e75c088" />
    <link rel="stylesheet" type="text/css" href="_static/tip.css?v=66ef22ed" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]]}, "TeX": {"Macros": {"coloneqq": "\\mathrel{\\mathpalette\\coloneqq@{}}", "parallel": "\\parallel"}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/custom.js?v=35170ed4"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The Mitosius" href="2-3_mitosius_prepare.html" />
    <link rel="prev" title="Introduction" href="2-1_introduction.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
  <div role="main">
    
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="reconstruction-calls">
<h1>Reconstruction Calls<a class="headerlink" href="#reconstruction-calls" title="Link to this heading">¶</a></h1>
<p>This section describes the functions calls of our reconstructions.
All our reconstructions are implemented for 2 and 3 spatial dimensions. Some of them are static
reconstruction (one single frame) and other are dynamic (multiple-frames) with 1 or 2 non-spatial dimensions.</p>
<section id="input-arguments-for-reconstruction-functions">
<h2>Input Arguments for Reconstruction Functions<a class="headerlink" href="#input-arguments-for-reconstruction-functions" title="Link to this heading">¶</a></h2>
<p>The input arguments that involve no or little preparation, and which are “easy” to define, and which are occupies little memory will be qualified as <strong>leight</strong>.</p>
<p>The input arguments that either need some careful preparation, or need some technical user defined choices, or occupies a lot of memory will be qualified as <strong>heavy</strong>.</p>
<p>For static (single frame) reconstructions, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">ve</span></code> are arrays, while for dynamic reconstructions
they are cell-arrays with one cell per data-bin and per frame.</p>
<p>For static reconstructions are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: the raw data. <strong>Complex-valued, sinlge-precision, heavy.</strong> Its size is <code class="docutils literal notranslate"><span class="pre">[nPt,</span> <span class="pre">nCh]</span></code> where <code class="docutils literal notranslate"><span class="pre">nPt</span></code> is the number of trajectory-points and <code class="docutils literal notranslate"><span class="pre">nCh</span></code> is the number of channels.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: the trajectory. <strong>Double-precision, heavy</strong>. Its size is <code class="docutils literal notranslate"><span class="pre">[frDim,</span> <span class="pre">nPt]</span></code> where the frame-dimension <code class="docutils literal notranslate"><span class="pre">frDim</span></code> is the spatial dimension of the frames (2 or 3) and <code class="docutils literal notranslate"><span class="pre">nPt</span></code> is the number of trajectory-points.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ve</span></code>: the volume elements (inverse density compensation). <strong>Single precision, heavy</strong>.  Its size is <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">nPt]</span></code> where <code class="docutils literal notranslate"><span class="pre">nPt</span></code> is the number of trajectory-points.</p></li>
</ul>
</div></blockquote>
<p>For multiple-frame (dynamic) reconstructions are</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: the cell-array of raw-data bins. <strong>Each cell is complex-valued, sinlge-precision, heavy.</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>: the cell-array of trajectory bins. <strong>Each cell is double precision, heavy.</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ve</span></code>: the cell-array of volume-elements bins. <strong>Each cell is single precision, heavy.</strong></p></li>
</ul>
</div></blockquote>
<p>The three variables <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">t</span></code> and <code class="docutils literal notranslate"><span class="pre">ve</span></code> (may it be arrays or cell-arrays) forms the <strong>Mitosius</strong>.
Refer to <a class="reference internal" href="2-3_mitosius_prepare.html"><span class="doc">The Mitosius</span></a> section to learn how to build <code class="docutils literal notranslate"><span class="pre">y</span></code> from the raw-data, how to build the trejectory <code class="docutils literal notranslate"><span class="pre">t</span></code> and how to estimate <code class="docutils literal notranslate"><span class="pre">ve</span></code> from <code class="docutils literal notranslate"><span class="pre">t</span></code>.
You can also build the trajectory <code class="docutils literal notranslate"><span class="pre">t</span></code> in your own way as long as you follow our convention described at the end of the <cite>Mitosius</cite> section.
You can evaluate  <code class="docutils literal notranslate"><span class="pre">ve</span></code> by our functions if your trajectory is supported by Monalisa. Else you can obtain <code class="docutils literal notranslate"><span class="pre">ve</span></code> by your own means.</p>
<p>If your mitosius is already stored on the disk at the math <code class="docutils literal notranslate"><span class="pre">m</span></code>, you can load it as follows:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="w">   </span><span class="p">=</span><span class="w"> </span><span class="n">bmMitosius_load</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;y&#39;</span><span class="p">);</span>
<span class="n">t</span><span class="w">   </span><span class="p">=</span><span class="w"> </span><span class="n">bmMitosius_load</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;t&#39;</span><span class="p">);</span>
<span class="n">ve</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="n">bmMitosius_load</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;ve&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>For any reconstruction is</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code>: the estimated coil sensitivity map. <strong>Complex valued, single precision, heavy.</strong> It is a 4D array of size <code class="docutils literal notranslate"><span class="pre">[frSize,</span> <span class="pre">nCh]</span></code>, where the frame-size <code class="docutils literal notranslate"><span class="pre">frSize</span></code> is the spatial size of the image and <code class="docutils literal notranslate"><span class="pre">nCh</span></code> is the number of coils.</p></li>
</ul>
</div></blockquote>
<p>You can estimate <code class="docutils literal notranslate"><span class="pre">C</span></code> either by your own means or by our procedure described in a later section.
If you already saved a low-resolution coil sensitivity matrix <code class="docutils literal notranslate"><span class="pre">C</span></code>, you can load it and resized it to the image-size as follows:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">C_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">size</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
<span class="n">C_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">C_size</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">frDim</span><span class="p">);</span>
<span class="n">C</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmImResize</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">C_size</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">);</span>
</pre></div>
</div>
<p>For any reconstructions are</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">N_u</span></code> : the size of the Cartesian gridd used for regridding in k-space. <strong>Double precision, leight.</strong> It is equal to <code class="docutils literal notranslate"><span class="pre">[Nx,</span> <span class="pre">Ny]</span></code> for 2 spatial dimensionts and it is equal to <code class="docutils literal notranslate"><span class="pre">[Nx,</span> <span class="pre">Ny,</span> <span class="pre">Nz]</span></code> for 3 spatial dimensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dK_u</span></code> : the step-size of the gridd used for regridding in k-space.  <strong>Single precision, leight</strong>. It is equal to  <code class="docutils literal notranslate"><span class="pre">[dK_x,</span> <span class="pre">dK_y]</span></code> for 2 spatial dimensions and it is equal to <code class="docutils literal notranslate"><span class="pre">[dK_x,</span> <span class="pre">dK_y,</span> <span class="pre">dK_z]</span></code> for 3 spatial dimensions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">frSize</span></code> : the size of the reconstructed frames. <strong>Double precision, leight</strong>. It is equal to  <code class="docutils literal notranslate"><span class="pre">[frN_x,</span> <span class="pre">frN_y]</span></code> for 2 spatial dimensions and it is equal to <code class="docutils literal notranslate"><span class="pre">[frN_x,</span> <span class="pre">frN_y,</span> <span class="pre">frN_z]</span></code> for 3 spatial dimensions.</p></li>
</ul>
</div></blockquote>
<p>We advise to set <code class="docutils literal notranslate"><span class="pre">frSize</span></code> equal to <code class="docutils literal notranslate"><span class="pre">N_u</span></code> for optimal image quality.
If <code class="docutils literal notranslate"><span class="pre">frSize</span></code> is componentwise smaller than <code class="docutils literal notranslate"><span class="pre">N_u</span></code> some croping and zero-filling
are used internally in the iterative reconstruction in order to regrid on the grid of size <code class="docutils literal notranslate"><span class="pre">N_u</span></code>.</p>
<p>These three arguments are the <strong>Companions</strong>. They are present in much of the functions involved in reconstructions.
The choice of <code class="docutils literal notranslate"><span class="pre">dK_u</span></code> and <code class="docutils literal notranslate"><span class="pre">N_u</span></code> sets the virtual cartesian grid used for regridding
and inherently sets the voxel size <span class="math notranslate nohighlight">\([\Delta r_x, \Delta r_y, \Delta r_z]\)</span>:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\Delta r_x = (1/dK_x)/N_x\\\Delta r_y = (1/dK_y)/N_y\\\Delta r_z = (1/dK_z)/N_z\end{aligned}\end{align} \]</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">dK_u</span> <span class="pre">=</span> <span class="pre">1./FoV</span></code> where <code class="docutils literal notranslate"><span class="pre">FoV</span></code> is the true (non-croped) reconstruction FoV.
The reconstruction FoV is set by the choice of <code class="docutils literal notranslate"><span class="pre">dK_u</span></code>, or reversely, <code class="docutils literal notranslate"><span class="pre">dK_u</span></code> is set by the reconstruction FoV.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The reconstruction FoV can be different from the acquisition FoV, that we will usually write <em>aFoV</em>.</p>
</div>
<p>In order to avoid numerical problems due to large differences between volume elements, we have to limit them by a user defined upper bound that we called</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ve_max</span></code>: the maximum volume element value that serves to limit <code class="docutils literal notranslate"><span class="pre">ve</span></code> in order to to avoid some convergence problems. <em>Single, scalar, leight</em>.</p></li>
</ul>
</div></blockquote>
<p>For iterative reconstruction, the reconstruction function need a start ismage as input that we use to write</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x0</span></code> : The initial image for iterative reconstruction. <strong>Complex valued, single precision, heavy</strong>.</p></li>
</ul>
</div></blockquote>
<p>The initial guess <code class="docutils literal notranslate"><span class="pre">x0</span></code> must have the same size as the reconstructed image. It must be a frame for static reconstructions and a cell-array for dynamic reconstructions.</p>
<p>The number of iterations in reconstruction functions are given by</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nIter</span></code>: the number of iterations of the outer-loop of iterative reconstruction. <strong>Double precision, scalar, leight.</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nCGD</span></code>: the number of iterations of the inner loop for the conjugate-gradient-descent. <strong>Double precision, scalar, leight.</strong></p></li>
</ul>
</div></blockquote>
<p>For iterative reconstructions,  <code class="docutils literal notranslate"><span class="pre">nIter</span></code> is the number of iterations of the ADMM algorithm (outer loop) and <code class="docutils literal notranslate"><span class="pre">nCGD</span></code> is the number of CGD (inner loop) iterations.
For least square reconstructions, <code class="docutils literal notranslate"><span class="pre">nIter</span></code> is the number of iterations of the CGD algorithm.</p>
<p>All least-square regularized reconstructions need a regularization weight. We provide an <strong>adaptive</strong> (automatic) and <strong>normal</strong>
(manual) way to provide that weight. The choice is done by setting the parameter</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">regul_mode</span></code> : Regularization mode. <strong>String, length</strong>. You can set it to <strong>normal</strong> or <strong>adaptive</strong>.</p></li>
</ul>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">regul_mode</span></code> is set to <em>adaptive</em>, the reconstruction function makes an automatic choice for the
regularization weight in order to reach an equilibrium between the the data-fidelity term and the regularization term
in the objective function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">regul_mode</span></code> is set to <strong>normal</strong>, then is the regularization weight given by the input argument</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">delta</span></code> : Regularisation parameter. <strong>Single precision, leight.</strong> The parameter <code class="docutils literal notranslate"><span class="pre">delta</span></code> can be either a scalar, or a list of 2 scalars <code class="docutils literal notranslate"><span class="pre">[delta_min,</span> <span class="pre">delta_max]</span></code> with <cite>delta_min &lt; delta_max</cite> , or a vector of length <cite>nIter</cite>.</p></li>
</ul>
</div></blockquote>
<p>If <code class="docutils literal notranslate"><span class="pre">delta</span></code> is a scalar, that number is used as regularization weight for each iteration.
If <code class="docutils literal notranslate"><span class="pre">delta</span></code> is a vector of length <cite>nIter</cite>, iteration number <cite>c</cite> is performed with the regularization weight equal to the value
at position <cite>c</cite> in the vector <code class="docutils literal notranslate"><span class="pre">delta</span></code>.
If <code class="docutils literal notranslate"><span class="pre">delta</span></code> is a list of 2 values <code class="docutils literal notranslate"><span class="pre">[delta_min,</span> <span class="pre">delta_max]</span></code> with <cite>delta_min &lt; delta_max</cite>, then is  <code class="docutils literal notranslate"><span class="pre">delta</span></code> replaced
by a list of length <cite>nIter</cite> by interpolating linearly <cite>nIter</cite> values between <cite>delta_min</cite> and <cite>delta_max</cite>.</p>
<p>The ADMM algorithm (for l1 regularization) needs an additional <strong>convergence parameter</strong> that we will write</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rho</span></code> : Convergence parameter for the ADMM algorithm. <strong>Single precision, scalar, leight.</strong> A rule of thumb is to set <code class="docutils literal notranslate"><span class="pre">rho</span></code> equal to a multiple (from 1 to 20) of <code class="docutils literal notranslate"><span class="pre">lambda</span></code> (We don’t say it is the best choice, we don’t take any responsibility for this).</p></li>
</ul>
</div></blockquote>
<p>For any non-cartesian reconstrucitons are</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Gu</span></code> : The gridding (sparse) matrix used for forward gridding in our iterative non-cartesian reconstructions. <strong>Of class `bmSparseMat`, heavy.</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Gut</span></code>: The transposed matrix of <code class="docutils literal notranslate"><span class="pre">Gu</span></code> used for backward (not inverse) gridding in our iterative non-cartesian reconstructions. <strong>Of class `bmSparseMat`, heavy.</strong></p></li>
</ul>
</div></blockquote>
<p>For the the sake of completeness and understanding of gridding, the construction of following sparase matrix is also implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Gn</span></code>: The gridding (sparse) matrix that attempts to realize an “inverse” operation performed by <code class="docutils literal notranslate"><span class="pre">Gu</span></code>. <strong>Of class `bmSparseMat`, heavy.</strong>  The inverse of <code class="docutils literal notranslate"><span class="pre">Gu</span></code> does not exist but <code class="docutils literal notranslate"><span class="pre">Gn</span></code> is constructed so that the composition <code class="docutils literal notranslate"><span class="pre">Gn</span> <span class="pre">Gu</span></code> is as close as possible to the identity.</p></li>
</ul>
</div></blockquote>
<p>Before running any iterative non-cartesian reconstructions, you must estimate the gridding (sparse) matrices:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmTraj2SparseMat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">N_u</span><span class="p">,</span><span class="w"> </span><span class="n">dK_u</span><span class="p">);</span>
</pre></div>
</div>
<p>These two sparse matrices depend on the trajectory, the reconstruction FoV (given by <code class="docutils literal notranslate"><span class="pre">dK_u</span></code>) and the k-space gridd size <code class="docutils literal notranslate"><span class="pre">N_u</span></code>.</p>
<p>For image (not k-space) motion compensation are</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tu</span></code>        : the deformation (sparse) matrix used for forward deformation in our motion compensated reconstructions. <strong>Of class `bmSparseMat`, heavy.</strong></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Tut</span></code>       : the transposed matrix of <code class="docutils literal notranslate"><span class="pre">Tut</span></code> for backward deformation. <strong>Of class `bmSparseMat`, heavy.</strong></p></li>
</ul>
</div></blockquote>
<p>Note that matrix <code class="docutils literal notranslate"><span class="pre">Tut</span></code> do not perform an inverse deformation. It realizes the transposed operation of the forward deformation.</p>
<p>For the the sake of completeness and understanding of gridding, the construction of following sparase matrix is also implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Tn</span></code>: The gridding (sparse) matrix that attempts to realize an “inverse” operation performed by <code class="docutils literal notranslate"><span class="pre">Tu</span></code>. <strong>Of class `bmSparseMat`, heavy.</strong> The inverse of <code class="docutils literal notranslate"><span class="pre">Tu</span></code> may or may  not exist. In any case, <code class="docutils literal notranslate"><span class="pre">Tn</span></code> is constructed so that the composition <code class="docutils literal notranslate"><span class="pre">Tn</span> <span class="pre">Tu</span></code> is as close as possible to the identity.</p></li>
</ul>
</div></blockquote>
<p>In order to monitor what is happening during a reconstruction (typically if this is taking lany hours) or just to have a track recoord of process after the reconstruction is finished, the following class has been implemented:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">witnessInfo</span></code>: Monitoring object to give as input argument to any iterative reconstruction function. <strong>Of the class `bmWitnessInfo`, Leight.</strong> It serves to store some monitoring information about the execution of the reconstruction process, in partocular some information about convergence and some 2D images at each iteration.</p></li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The reconstructed image <code class="docutils literal notranslate"><span class="pre">x</span></code> and the monitoring object <code class="docutils literal notranslate"><span class="pre">witnessInfo</span></code> are saved in the current directory during the reconstruction.</p>
</div>
<p>We have described all input arguments that you need to know to use our reconstruction functions. There are other but it is not critical to know them.</p>
<p>Here is an example that summarizes the definitions of the leight input arguments:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">nIter</span><span class="w">               </span><span class="p">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"> </span><span class="c">% number of iteration of the outer-loop of the algorithm.</span>
<span class="n">nCGD</span><span class="w">                </span><span class="p">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="c">% number of CGD iterations</span>
<span class="n">ve_max</span><span class="w">              </span><span class="p">=</span><span class="w"> </span><span class="mi">6</span><span class="o">*</span><span class="nb">prod</span><span class="p">(</span><span class="n">dK_u</span><span class="p">(:));</span><span class="w"> </span><span class="c">% maximum value of the volume elements. This is imprtant to avoid some numerical problems.</span>
<span class="n">regul_mode</span><span class="w">          </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;normal&#39;</span><span class="p">;</span><span class="w"> </span><span class="c">% must be &#39;normal&#39; or &#39;adaptive&#39;.</span>

<span class="n">delta</span><span class="w">               </span><span class="p">=</span><span class="w"> </span><span class="mf">0.3</span><span class="p">;</span><span class="w">          </span><span class="c">% regularization parameter present in the objective function of iterative reconstructions.</span>
<span class="n">rho</span><span class="w">                 </span><span class="p">=</span><span class="w"> </span><span class="mi">10</span><span class="o">*</span><span class="n">delta</span><span class="p">;</span><span class="w">     </span><span class="c">% convergence parameter for ADMM</span>

<span class="n">witness_label</span><span class="w">       </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;myReconLabel&#39;</span><span class="p">;</span><span class="w">   </span><span class="c">% This label serves to name the files stored in the current directory during the reconstruction;</span>
<span class="n">witness_ind</span><span class="w">         </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="n">nIter</span><span class="p">;</span><span class="w">        </span><span class="c">% or []. If not empty, the current reconstructed image will be saved in the current directory if the current iteration number (outer loop) is in ``wintess_ind``.</span>
<span class="n">save_witnessIm_flag</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w">             </span><span class="c">% If true, the witness images (some 2D images) will be saved at every iteration of the outer loop. Set to false if rapidity is a priority.</span>

<span class="n">myWitnessInfo</span><span class="w">       </span><span class="p">=</span><span class="w"> </span><span class="n">bmWitnessInfo</span><span class="p">(</span><span class="n">witness_label</span><span class="p">,</span><span class="w"> </span><span class="n">witness_ind</span><span class="p">,</span><span class="w"> </span><span class="n">save_witnessIm_flag</span><span class="p">);</span><span class="w"> </span><span class="c">% Create an instance of bmWitnessInfo.</span>
</pre></div>
</div>
</section>
<section id="non-cartesian-static-reconstructions">
<h2>Non-Cartesian Static Reconstructions<a class="headerlink" href="#non-cartesian-static-reconstructions" title="Link to this heading">¶</a></h2>
<p>All reconstrucion calls presented in this section can be tested using the script
<a class="reference external" href="https://github.com/MattechLab/monalisa/blob/main/demo/script_demo/script_recon_calls/static_recon_calls_script.m">static_recon_calls_script</a>.
that you can also find in the <cite>script_demo</cite> directory of Monalisa.</p>
<section id="mathilda-the-initial-image-reconstruction">
<span id="mathilda"></span><h3>Mathilda, the Initial Image-Reconstruction<a class="headerlink" href="#mathilda-the-initial-image-reconstruction" title="Link to this heading">¶</a></h3>
<p>Mathilda is our gridded, zero-padded, inverse DFT reconstruction for non-cartesian trajectories.
If the data are well sampled, then leads Mathilda already to a descent image.
For iterative reconstruction of under sampled data, we mostly use Mathilda to perform the initial guess <code class="docutils literal notranslate"><span class="pre">x0</span></code></p>
<p>Here is the function call:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">x0</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmMathilda</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">N_u</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="n">dK_u</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[]);</span>
</pre></div>
</div>
<p>Note that you can also give the empty matrix <cite>[]</cite> instead of the coil-sensitivity C. In that case will Mathilda return the list of coil-images.
You may then combine those images by any combination of your choice. If you don’t have the coil-sensitivities, you can for example combine the
coil-images by a root-mean-square, but the phase of the image is lost in that case.</p>
<p>You can take a look at the image by running</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">bmImage</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>
</pre></div>
</div>
<p>Be aware that there could be a crash if the memory needed is too big,
and it can take a lot of time. Maybe it’s better if you first test with small N_u and frSize values.</p>
</section>
<section id="sensa">
<span id="id1"></span><h3>Sensa<a class="headerlink" href="#sensa" title="Link to this heading">¶</a></h3>
<p>This is our implementation of the iterative-SENSE reconstruction <a class="footnote-reference brackets" href="#id11" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> for non-cartesian data.
It is a single-frame least-square reconstruction without regularisation. The objective function is minimized
iteratively with the conjugate gradient descent (CGD) algorithm.</p>
<p>Since it is a single frame reconstruction, it can be applied independently for all frames of a multiple-frame
image, but it does not share information between frames. Consequently, it performs poorly with heavily undersampled data.
However, despite its limitations, this method is important in the theoretical framework of reconstruction
and finds applications in specific cases.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">witness_label</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;sens_demo&#39;</span><span class="p">;</span>
<span class="n">witnessInfo</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmWitnessInfo</span><span class="p">(</span><span class="n">witness_label</span><span class="p">,</span><span class="w"> </span><span class="n">witness_ind</span><span class="p">);</span>

<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmSensa</span><span class="p">(</span><span class="w">    </span><span class="n">x0</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">y</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">ve</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">Gu</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">Gut</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">witnessInfo</span><span class="w"> </span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="steva">
<span id="id3"></span><h3>Steva<a class="headerlink" href="#steva" title="Link to this heading">¶</a></h3>
<p>Single-frame Least-square Regularized Reconstruction,
where reularizaiton is the l1-norm of spatial gradient of the image.</p>
<p>witness_label = ‘steva_demo’;</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmSteva</span><span class="p">(</span><span class="w">    </span><span class="n">x0</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">y</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">ve</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">Gu</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">Gut</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">rho</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;normal&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">witnessInfo</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="sleva">
<span id="id4"></span><h3>Sleva<a class="headerlink" href="#sleva" title="Link to this heading">¶</a></h3>
<p>Single-frame Least-square Regularized Reconstruction, where reularizaiton is the l2-norm of the image.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmSleva</span><span class="p">(</span><span class="w">    </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">rho</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;normal&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                </span><span class="n">witnessInfo</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="deformation-fields">
<h2>Deformation-Fields<a class="headerlink" href="#deformation-fields" title="Link to this heading">¶</a></h2>
<p>The deformation matrices (and their corresponding transposed matrices) serves to perform temporal regularization with movement compensation.
The multiplication of an image vector by a deformation matrix defroms the image according to the deformation-field
encoded in the deformation-matrix. A deformation-field must therefore be estimated prior to the definition of any deformation matrix.</p>
<p>Here is a possible way to estimate deformation-fields. In that example, the deformation-field
between each frame and its (past and future) temporal neighboring frame is estimated with the <cite>imregdemons</cite> function of Matlab.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">%% deformation field evaluation with imReg Demon</span>
<span class="n">reg_file</span><span class="w">                    </span><span class="p">=</span><span class="w"> </span><span class="s">&#39;C:\path\to\your\reg_file&#39;</span><span class="p">;</span>
<span class="p">[</span><span class="n">DF_to_prev</span><span class="p">,</span><span class="w"> </span><span class="n">imReg_to_prev</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmImDeformFieldChain_imRegDemons23</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;curr_to_prev&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">reg_file</span><span class="p">,</span><span class="w"> </span><span class="n">reg_mask</span><span class="p">);</span><span class="w"> </span><span class="c">% past temporal neighbor</span>
<span class="p">[</span><span class="n">DF_to_next</span><span class="p">,</span><span class="w"> </span><span class="n">imReg_to_next</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmImDeformFieldChain_imRegDemons23</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;curr_to_next&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">500</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">reg_file</span><span class="p">,</span><span class="w"> </span><span class="n">reg_mask</span><span class="p">);</span><span class="w"> </span><span class="c">% futur temporal neighbor</span>
</pre></div>
</div>
<p>Once the deformation-fields are estimated, the deformation-matrices can simply be defined as follows.:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">%% deformation fields to sparse matrices</span>
<span class="p">[</span><span class="n">Tu1</span><span class="p">,</span><span class="w"> </span><span class="n">Tu1t</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmImDeformField2SparseMat</span><span class="p">(</span><span class="n">DF_to_prev</span><span class="p">,</span><span class="w"> </span><span class="n">N_u</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="p">[</span><span class="n">Tu2</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2t</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmImDeformField2SparseMat</span><span class="p">(</span><span class="n">DF_to_next</span><span class="p">,</span><span class="w"> </span><span class="n">N_u</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the deformation-fields can be estimated by any tool as chosen by the user. Here is the use of <cite>imregdemons</cite> just an example.</p>
<p>The computed deformation-matrices can be stored and reused many times with different functions described below.</p>
</section>
<section id="non-cartesian-chain-reconstructions">
<h2>Non-Cartesian Chain Reconstructions<a class="headerlink" href="#non-cartesian-chain-reconstructions" title="Link to this heading">¶</a></h2>
<p>The next functions can be called with or without deformation-matrices given as argument. We will see both cases.</p>
<section id="tevamorphosia-chain">
<span id="id5"></span><h3>TevaMorphosia_chain<a class="headerlink" href="#tevamorphosia-chain" title="Link to this heading">¶</a></h3>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmTevaMorphosia_chain</span><span class="p">(</span>
<span class="w">    </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">Tu</span><span class="p">,</span><span class="w"> </span><span class="n">Tut</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">rho</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;normal&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">bmWitnessInfo</span><span class="p">(</span><span class="n">witness_label</span><span class="p">,</span><span class="w"> </span><span class="n">witness_ind</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="tevaduomorphosia-chain">
<span id="id6"></span><h3>TevaDuoMorphosia_chain<a class="headerlink" href="#tevaduomorphosia-chain" title="Link to this heading">¶</a></h3>
<p>Same as TevaMorphosia but with forward and backward temporal regularization, with or without deformation fields.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmTevaDuoMorphosia_chain</span><span class="p">(</span>
<span class="w">    </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">Tu1</span><span class="p">,</span><span class="w"> </span><span class="n">Tu1t</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2t</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">rho</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;normal&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">    </span><span class="n">witnessInfo</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="sensitivamorphosia-chain">
<span id="id7"></span><h3>SensitivaMorphosia_chain<a class="headerlink" href="#sensitivamorphosia-chain" title="Link to this heading">¶</a></h3>
<p>Least Square Regularized (LSR) reconstruction, where regularization is the squared 2 norm of
finite difference time derivative.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">witnessInfo</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmWitnessInfo</span><span class="p">([</span><span class="n">witness_label</span><span class="p">,</span><span class="w"> </span><span class="nb">num2str</span><span class="p">(</span><span class="nb">i</span><span class="p">)],</span><span class="w"> </span><span class="n">witness_ind</span><span class="p">);</span>

<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmSensitivaMorphosia_chain</span><span class="p">(</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Tu</span><span class="p">,</span><span class="w"> </span><span class="n">Tut</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">regul_mode</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">witnessInfo</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="sensitivaduomorphosia-chain">
<span id="id8"></span><h3>SensitivaDuoMorphosia_chain<a class="headerlink" href="#sensitivaduomorphosia-chain" title="Link to this heading">¶</a></h3>
<p>Least Square Regularized (LSR) recon, where regularization is the squared 2 norm of
finite difference time derivative.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">witnessInfo</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmWitnessInfo</span><span class="p">(</span><span class="n">witness_label</span><span class="p">,</span><span class="w"> </span><span class="n">witness_ind</span><span class="p">);</span>

<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmSensitivaDuoMorphosia_chain</span><span class="p">(</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Tu1</span><span class="p">,</span><span class="w"> </span><span class="n">Tu1t</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2t</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">regul_mode</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">witnessInfo</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="non-cartesian-sheet-reconstructions">
<h2>Non-Cartesian Sheet Reconstructions<a class="headerlink" href="#non-cartesian-sheet-reconstructions" title="Link to this heading">¶</a></h2>
<section id="tevamorphosia-sheet">
<span id="id9"></span><h3>TevaMorphosia_sheet<a class="headerlink" href="#tevamorphosia-sheet" title="Link to this heading">¶</a></h3>
<p>Least Square Regularized (LSR) recon, where regularization is the squared 2 norm of
finite difference time derivative.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">witnessInfo</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmWitnessInfo</span><span class="p">(</span><span class="n">witness_label</span><span class="p">,</span><span class="w"> </span><span class="n">witness_ind</span><span class="p">);</span>

<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmTevaMorphosia_sheet</span><span class="p">(</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Tu1</span><span class="p">,</span><span class="w"> </span><span class="n">Tu1t</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2t</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">regul_mode</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">witnessInfo</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="sensitivamorphosia-sheet">
<span id="id10"></span><h3>SensitivaMorphosia_sheet<a class="headerlink" href="#sensitivamorphosia-sheet" title="Link to this heading">¶</a></h3>
<p>Least Square Regularized (LSR) recon, where regularization is the squared 2 norm of
finite difference time derivative.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">witnessInfo</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmWitnessInfo</span><span class="p">(</span><span class="n">witness_label</span><span class="p">,</span><span class="w"> </span><span class="n">witness_ind</span><span class="p">);</span>

<span class="n">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmSensitivaMorphosia_sheet</span><span class="p">(</span>
<span class="w">        </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">frSize</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">Tu1</span><span class="p">,</span><span class="w"> </span><span class="n">Tu1t</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2</span><span class="p">,</span><span class="w"> </span><span class="n">Tu2t</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">regul_mode</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nCGD</span><span class="p">,</span><span class="w"> </span><span class="n">ve_max</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">        </span><span class="n">nIter</span><span class="p">,</span>
<span class="w">        </span><span class="n">witnessInfo</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="partial-cartesian-static-reconstructions">
<h2>Partial-Cartesian Static Reconstructions<a class="headerlink" href="#partial-cartesian-static-reconstructions" title="Link to this heading">¶</a></h2>
</section>
<section id="partial-cartesian-chain-reconstructions">
<h2>Partial-Cartesian Chain Reconstructions<a class="headerlink" href="#partial-cartesian-chain-reconstructions" title="Link to this heading">¶</a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Pruessmann, K. P., Weiger, M., Börnert, P., &amp; Boesiger, P. (2001).
Advances in sensitivity encoding with arbitrary k-space trajectories. Magnetic Resonance in Medicine, 46(4), 638–651.
<a class="reference external" href="https://doi.org/10.1002/mrm.1241">https://doi.org/10.1002/mrm.1241</a>.</p>
</aside>
</aside>
</section>
</section>


          </div>
          
        </div>
      </div>  <!-- This includes the original document content -->

    <!-- Back to Top Button -->
    <button onclick="scrollToTop()" id="back-to-top" title="Go to top">↑</button>
  </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Monalisa</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1_quick_start.html">Quick Start</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="2_contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="2-1_introduction.html">Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Reconstruction Calls</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#input-arguments-for-reconstruction-functions">Input Arguments for Reconstruction Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-cartesian-static-reconstructions">Non-Cartesian Static Reconstructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#deformation-fields">Deformation-Fields</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-cartesian-chain-reconstructions">Non-Cartesian Chain Reconstructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#non-cartesian-sheet-reconstructions">Non-Cartesian Sheet Reconstructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-cartesian-static-reconstructions">Partial-Cartesian Static Reconstructions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#partial-cartesian-chain-reconstructions">Partial-Cartesian Chain Reconstructions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="2-3_mitosius_prepare.html">The Mitosius</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-4_binning_masks.html">Binning: Flexible Readout Rearrangement</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-5_coil_sensitivity_map.html">Coil Sensitivity Map Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-6_prescan_acquisition.html">Acquisition Guidelines for Coil Sensitivity Estimation using Prescans</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="3_examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="4_api.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="5_docker.html">Docker for Monalisa</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_ack_contribution.html">Acknowledgment and Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="7_discussions.html">Discussion</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="2_contents.html">Contents</a><ul>
      <li>Previous: <a href="2-1_introduction.html" title="previous chapter">Introduction</a></li>
      <li>Next: <a href="2-3_mitosius_prepare.html" title="next chapter">The Mitosius</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Bastien Milani.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/2-2_reconstruction_calls.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>