<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>First Example: Sequential Binning &#8212; Monalisa 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="_static/custom-navigation.css?v=899df2ba" />
    <link rel="stylesheet" type="text/css" href="_static/custom-button.css?v=35775deb" />
    <link rel="stylesheet" type="text/css" href="_static/important.css?v=8e75c088" />
    <link rel="stylesheet" type="text/css" href="_static/tip.css?v=66ef22ed" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/custom.js?v=35170ed4"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Second Example: Task-Based (Hi-Fi) fMRI" href="2-4-2_binning_eye_2.html" />
    <link rel="prev" title="Binning: Flexible Readout Rearrangement" href="2-4_binning_masks.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
  <div role="main">
    
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="first-example-sequential-binning">
<h1>First Example: Sequential Binning<a class="headerlink" href="#first-example-sequential-binning" title="Link to this heading">¶</a></h1>
<p>Sequential binning is one of the simplest ways to partition lines, splitting data sequentially by acquisition time. This method is particularly useful for imaging modalities that depend on temporal dynamics, such as resting-state fMRI, where we want to monitor the timecourse of the BOLD signal across brain regions. In sequential binning, we aim to generate a sequence of frames as illustrated below:</p>
<a class="reference internal image-reference" href="_images/sequential_binning.png"><img alt="Sequential binning groups data based on time." class="align-center" src="_images/sequential_binning.png" style="width: 90%;" />
</a>
<p>For this example, we assume the unit of time is milliseconds, and that we want to produce a temporal sequence of images, each one containing data acquired over a period of 2 seconds (window size).</p>
<section id="steps-for-sequential-binning">
<h2>Steps for Sequential Binning<a class="headerlink" href="#steps-for-sequential-binning" title="Link to this heading">¶</a></h2>
<ol class="arabic">
<li><p><strong>Initialize and Set Parameters</strong>:
Start by configuring the temporal window size and extracting metadata from the acquisition parameters. The <cite>RawDataReader</cite> object provides the necessary data for binning, such as the number of measures, the number of segments per shot (<cite>nSeg</cite>), and timestamps for each readout.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Set temporal window size</span>
<span class="n">temporalWindowSec</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c">%magic number</span>

<span class="c">% Extract parameters from acquisition</span>
<span class="n">acquisitionParams</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">reader</span><span class="p">.</span><span class="n">acquisitionParams</span><span class="p">;</span>
<span class="c">% Total amount of lines</span>
<span class="n">nLines</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">acquisitionParams</span><span class="p">.</span><span class="n">nLine</span><span class="p">;</span>
<span class="c">% This only makes sense for phyllotaxis spiral</span>
<span class="n">nSeg</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">acquisitionParams</span><span class="p">.</span><span class="n">nSeg</span><span class="p">;</span>
<span class="c">% Non steady state lines</span>
<span class="n">nSegNotSS</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">acquisitionParams</span><span class="p">.</span><span class="n">nShot_off</span><span class="o">*</span><span class="n">acquisitionParams</span><span class="p">.</span><span class="n">nSeg</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><p><strong>Adjust and Scale Timestamps</strong>:
The timestamps from the acquisition are adjusted to remove non-steady-state measurements, which are not used for image reconstruction. These timestamps are converted into milliseconds for easier manipulation.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Adjust timestamps and scale to milliseconds</span>
<span class="n">costTime</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mf">2.5</span><span class="p">;</span><span class="w">  </span><span class="c">% Siemens-specific constant</span>
<span class="n">timeStamp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">acquisitionParams</span><span class="p">.</span><span class="n">timestamp</span><span class="p">;</span>
<span class="n">timeStamp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">timeStamp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">min</span><span class="p">(</span><span class="n">timeStamp</span><span class="p">);</span>
<span class="c">% Relative time w.r.t. beginning of acquisition in milliseconds</span>
<span class="n">timestampMs</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">timeStamp</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">costTime</span><span class="p">;</span>
<span class="c">% Non steady state time: example of filtering</span>
<span class="n">notSSTime</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">timestampMs</span><span class="p">(</span><span class="n">nSegNotSS</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>Determine the Number of Temporal Bins</strong>:
Based on the total duration of valid data, calculate how many temporal bins (masks) are needed. Each bin corresponds to a fixed duration (e.g., 2 seconds).</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Calculate total duration and number of temporal bins (masks)</span>
<span class="n">totalDuration</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="n">timestampMs</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">notSSTime</span><span class="p">;</span>
<span class="n">temporalWindowMs</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">temporalWindowSec</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1000</span><span class="p">;</span>
<span class="n">nMasks</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">floor</span><span class="p">(</span><span class="n">totalDuration</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">temporalWindowMs</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>Create and Assign Bins</strong>:
For each temporal bin, identify the corresponding measurements based on their timestamps. The binning masks (<cite>seqMask</cite>) are initialized as logical arrays, where each bin corresponds to a set of measurements that occurred within the temporal window. SI projections (special measurements that should not contribute to image reconstruction) are excluded from each bin.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Initialize binning masks</span>
<span class="n">seqMask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="p">(</span><span class="n">nMasks</span><span class="p">,</span><span class="w"> </span><span class="n">nLines</span><span class="p">);</span>
<span class="c">% Populate the masks for each time window</span>
<span class="k">for</span><span class="w"> </span><span class="nb">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span><span class="n">nMasks</span>
<span class="w">      </span><span class="n">windowStart</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">notSSTime</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="nb">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">temporalWindowMs</span><span class="p">;</span>
<span class="w">      </span><span class="n">windowEnd</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">windowStart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">temporalWindowMs</span><span class="p">;</span>
<span class="w">      </span><span class="c">% Create mask for the current time window</span>
<span class="w">      </span><span class="n">mask</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">(</span><span class="n">timestampMs</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">windowStart</span><span class="p">)</span><span class="w"> </span><span class="k">...</span>
<span class="w">      </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">timestampMs</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">windowEnd</span><span class="p">);</span>
<span class="w">      </span><span class="c">% Assign the mask to the bin matrix</span>
<span class="w">      </span><span class="n">seqMask</span><span class="p">(</span><span class="nb">i</span><span class="p">,</span><span class="w"> </span><span class="p">:)</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</div>
</li>
</ol>
<p>The reconstructed images result from the contribution of each line within the associated bin. In this case, the image represents the average BOLD signal over the 2-second interval corresponding to each bin.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The binning process is usually composed of two main parts:</p>
<ol class="arabic simple">
<li><p>A filtering of data not adeguate for image reconstruction (e.g., not steady state)</p></li>
<li><p>A partition of the data, to produce several frames.</p></li>
</ol>
<p>Clearly the partitioning depends on the analysis that will be applied later.
For example, to estimate rigid motion we are need to apply sequential binning.</p>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>  <!-- This includes the original document content -->

    <!-- Back to Top Button -->
    <button onclick="scrollToTop()" id="back-to-top" title="Go to top">↑</button>
  </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Monalisa</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1_quick_start.html">Quick Start</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="2_contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="2-1_introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-2_reconstruction_calls.html">Reconstruction Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-3_mitosius_prepare.html">The Mitosius</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="2-4_binning_masks.html">Binning: Flexible Readout Rearrangement</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">First Example: Sequential Binning</a></li>
<li class="toctree-l3"><a class="reference internal" href="2-4-2_binning_eye_2.html">Second Example: Task-Based (Hi-Fi) fMRI</a></li>
<li class="toctree-l3"><a class="reference internal" href="2-4-3_binning_respiratory.html">Third Example: Respiratory Binning for Motion-Resolved Cardiac MRI using Superior-Inferior (SI) Projections</a></li>
<li class="toctree-l3"><a class="reference internal" href="2-4-4_binning_cardiac.html">Fourth Example: Cardiac Binning for Motion-Resolved Cardiac MRI using Superior-Inferior (SI) Projections</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="2-5_coil_sensitivity_map.html">Coil Sensitivity Map Estimation</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-6_prescan_acquisition.html">Acquisition Guidelines for Coil Sensitivity Estimation using Prescans</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="3_examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="4_api.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="5_docker.html">Docker for Monalisa</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_ack_contribution.html">Acknowledgment and Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="7_discussions.html">Discussion</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="2_contents.html">Contents</a><ul>
  <li><a href="2-4_binning_masks.html">Binning: Flexible Readout Rearrangement</a><ul>
      <li>Previous: <a href="2-4_binning_masks.html" title="previous chapter">Binning: Flexible Readout Rearrangement</a></li>
      <li>Next: <a href="2-4-2_binning_eye_2.html" title="next chapter">Second Example: Task-Based (Hi-Fi) fMRI</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Bastien Milani.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/2-4-1_binning_eye_1.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>