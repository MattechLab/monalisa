<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Coil Sensitivity Map Estimation &#8212; Monalisa 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <link rel="stylesheet" type="text/css" href="_static/custom-navigation.css?v=899df2ba" />
    <link rel="stylesheet" type="text/css" href="_static/custom-button.css?v=35775deb" />
    <link rel="stylesheet" type="text/css" href="_static/important.css?v=8e75c088" />
    <link rel="stylesheet" type="text/css" href="_static/tip.css?v=66ef22ed" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]]}, "TeX": {"Macros": {"coloneqq": "\\mathrel{\\mathpalette\\coloneqq@{}}", "parallel": "\\parallel"}}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/custom.js?v=35170ed4"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Acquisition Guidelines for Coil Sensitivity Estimation using Prescans" href="2-6_prescan_acquisition.html" />
    <link rel="prev" title="Fourth Example: Cardiac Binning for Motion-Resolved Cardiac MRI using Superior-Inferior (SI) Projections" href="2-4-4_binning_cardiac.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
  <div role="main">
    
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="coil-sensitivity-map-estimation">
<h1>Coil Sensitivity Map Estimation<a class="headerlink" href="#coil-sensitivity-map-estimation" title="Link to this heading">¶</a></h1>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#coil-sensitivity-from-pre-scan-images" id="id3">Coil sensitivity from pre-scan images</a></p></li>
<li><p><a class="reference internal" href="#coil-sensitivity-from-raw-data-pre-scans" id="id4">Coil sensitivity from raw data pre-scans</a></p></li>
<li><p><a class="reference internal" href="#automated-estimation" id="id5">Automated Estimation</a></p></li>
<li><p><a class="reference internal" href="#manual-estimation" id="id6">Manual Estimation</a></p>
<ul>
<li><p><a class="reference internal" href="#acquisition-parameters" id="id7">Acquisition Parameters</a></p></li>
<li><p><a class="reference internal" href="#mask-creation" id="id8">Mask Creation</a></p>
<ul>
<li><p><a class="reference internal" href="#threshold" id="id9">Threshold</a></p></li>
<li><p><a class="reference internal" href="#region-of-interest" id="id10">Region of Interest</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#sensitivity-approximation" id="id11">Sensitivity Approximation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#code-explanation" id="id12">Code Explanation</a></p>
<ul>
<li><p><a class="reference internal" href="#path-selection" id="id13">Path selection</a></p></li>
<li><p><a class="reference internal" href="#parameters" id="id14">Parameters</a></p></li>
<li><p><a class="reference internal" href="#data-extraction" id="id15">Data extraction</a></p></li>
<li><p><a class="reference internal" href="#gridding-matrices" id="id16">Gridding Matrices</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id17">Mask Creation</a></p></li>
<li><p><a class="reference internal" href="#coil-sensitivity-estimation" id="id18">Coil Sensitivity Estimation</a></p></li>
<li><p><a class="reference internal" href="#improved-estimation" id="id19">Improved Estimation</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>This section explains how to generate an estimate of the coil sensitivity map using this framework.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>For this an acquisition of the body coil pre-scan and the selected acquisition coil pre-scan data is required. Either you need pre-scan images or two pre-scan raw datas.
For the moment we only support ISMRMRD (.mrd) and Siemens raw data (.dat) files.</p>
</div>
<section id="coil-sensitivity-from-pre-scan-images">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Coil sensitivity from pre-scan images</a><a class="headerlink" href="#coil-sensitivity-from-pre-scan-images" title="Link to this heading">¶</a></h2>
<p>Computing coil senstivity from pre-scan images is simpler but yields a worst estimation of the real coil sensitivity. You need two body coil images and one image per acquisition coil.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The FOV position and orientation of the images should be the same.</p>
</div>
<p>This script <a class="reference external" href="https://github.com/MattechLab/monalisa/blob/main/examples/scripts/coilSense_from_prescan_images_script.m">https://github.com/MattechLab/monalisa/blob/main/examples/scripts/coilSense_from_prescan_images_script.m</a> illustrates how to run the coilsensitivity estimation from prescan images. The estimation of the coil sensitivity is done in two steps:
1. In the first step the user should define a pre-scan mask on the ROI using the body coil image, this helps to estimate the coil sensitivity excluding the noise.
2. In the secon step the function bmCoilSense_prescan_coilSense is called, to estimate the acquisition coils sentitivities.</p>
<p>The images are required to be 3D matlab arrays.</p>
</section>
<section id="coil-sensitivity-from-raw-data-pre-scans">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">Coil sensitivity from raw data pre-scans</a><a class="headerlink" href="#coil-sensitivity-from-raw-data-pre-scans" title="Link to this heading">¶</a></h2>
<p>The process of extracting the acquisition metadata and the parameters for the generation of the ROI mask can either be done automatically or controlled by the user.
The used mode can be changed using the dedicated flag at the start of the <cite>coilSense_from_prescan_rawdata_nonCart_ISMRMRD_script</cite> script.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The FOV position and orientation of the raw-data pre-scans should be the same.</p>
</div>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Flag; decide on values automatically if true, require user input if false</span>
<span class="n">autoFlag</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</pre></div>
</div>
<p>At the start of the script, the paths to the files and to the folder where the map should be saved can be set.
The resulting map is only saved if the save flag is set to true.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="c">% Flag; saves the coil sensitivity map if true</span>
<span class="n">doSave</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
</pre></div>
</div>
<p>If the paths aren’t set in the script, a file selection dialog box will pop up at run time, where the user has to select the pre-scan .mdr files.
In order the body coil file,  the surface coil file and the directory where the result is saved (if the flag is set to true).</p>
</section>
<section id="automated-estimation">
<span id="automatedestimation"></span><h2><a class="toc-backref" href="#id5" role="doc-backlink">Automated Estimation</a><a class="headerlink" href="#automated-estimation" title="Link to this heading">¶</a></h2>
<p>In automated mode, the user only needs to provide one additional input: confirming the selection of the region of interest (ROI) for reconstruction.
This region is essential for estimating the coil sensitivity. Ensure that the blue box completely encompasses the area you wish to image, but select the smallest possible bounding box. Pixels outside this region are estimated by solving the Laplace equation:</p>
<div class="math notranslate nohighlight">
\[\Delta f = 0\]</div>
<p>The blue selection can be modified by dragging the vertices of the boxes. The values are updated either after releasing the vertex or, if the “Update on move” option is ticked, while dragging the vertex.
Two of these figures will open, during which the code execution is interrupted until confirmation, one for Root Mean Square (RMS) values and one for the Maximum Intensity Projection (MIP):</p>
<a class="reference internal image-reference" href="_images/ROI-selection.png"><img alt="The region of interest selection has to be confirmed." src="_images/ROI-selection.png" style="width: 100%;" />
</a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The images in this figure are created by summing along an axis to represent the view.
If this option doesn’t create a usable image, please use the <a class="reference internal" href="#roifigures"><span class="std std-ref">figures</span></a> in the manual estimation mode.</p>
<p>The minimum and maximum values can only be changed directly in manual estimation.</p>
</div>
<p>After checking that the ROI is correct, the selction has to be confirmed by pressing on the “Confirm Selection” button.</p>
<p>The rest of the estimation is done automatically and the resulting matrix is saved in the given folder with the following naming convention:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">coil_sensitivity_map_yyyy-mm-dd-hh-mm.mat</span></code></p>
</div></blockquote>
</section>
<section id="manual-estimation">
<h2><a class="toc-backref" href="#id6" role="doc-backlink">Manual Estimation</a><a class="headerlink" href="#manual-estimation" title="Link to this heading">¶</a></h2>
<p>Using the manual estimation requires some more confirmation from the user. Namely of the parameters extracted and the threshold to differentiate between noise and data.
There will be more figures shown that allow to check the region of interest in more detail as well as the effect of the secondary coil sensitivity estimation.</p>
<section id="acquisition-parameters">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Acquisition Parameters</a><a class="headerlink" href="#acquisition-parameters" title="Link to this heading">¶</a></h3>
<p>The acquisition parameters are automatically extracted from the ISMRM raw data files and presented in the following figure. Make sure that the values displayed are correct.</p>
<a class="reference internal image-reference" href="_images/acquisition_parameters.png"><img alt="Modify and confirm the acquisition parameters." class="align-center" src="_images/acquisition_parameters.png" style="width: 90%;" />
</a>
<p>The code execution is interrupted until the figure is closed.
The table allows the user to modify the extracted acquisition parameters in the third column “User Value”.
On the right, the navigation and the trajectory type can be selected, as well as an option to remove oversampled data.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only the non-cartesian trajectory and the navigation using the SI line is implemented.</p>
</div>
<p>This has to be done for the body coil first and then for the surface coils.
To select a good number for the shots to be dropped as they are taken before the steady state is reached, a figure is shown.
The figure indicates which number was selected automatically.</p>
<p>Here is the figure for the SI navigation together with the same figure zoomed into the first few shots:</p>
<a class="reference internal image-reference" href="_images/Steady-state-determination.png"><img alt="Steady state is determined by looking at the evolution of the magnitude of the SI projection." src="_images/Steady-state-determination.png" style="width: 100%;" />
</a>
<p>Note that the number of shots to be discarded can be updated by dragging the vertical line in this figure.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Only the number of channels (coils) will be stored from the body coil.
The changes to the other parameters have to be done in the second figure for the surface coils.</p>
</div>
</section>
<section id="mask-creation">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Mask Creation</a><a class="headerlink" href="#mask-creation" title="Link to this heading">¶</a></h3>
<p>The mask is used to select voxels for which valuable data is present. This should exclude artifacts and noise.
To achieve this, thresholds and a region of interest (ROI) selection are used to create the mask.</p>
<section id="threshold">
<h4><a class="toc-backref" href="#id9" role="doc-backlink">Threshold</a><a class="headerlink" href="#threshold" title="Link to this heading">¶</a></h4>
<p>To ensure that the estimation is only done for voxels that contain meaningful data, a threshold is used to seperate noise from data.
One threshold is for the RMS value of the voxels, which is calculated over all the body coils and the other is for the MIP value.
Both of them are set seperately by dragging the two lines in the figure below:</p>
<a class="reference internal image-reference" href="_images/thresholdRMSMIP.png"><img alt="The thresholds are determined by looking at the images and dragging the lines." class="align-center" src="_images/thresholdRMSMIP.png" style="width: 70%;" />
</a>
<p>The figure allows to change the view of the two images as well as changing between a binary and a continuous representation.
While dragging the lines in the graph in the top half, the images update the voxels to show which are below the threshold.</p>
</section>
<section id="region-of-interest">
<span id="roifigures"></span><h4><a class="toc-backref" href="#id10" role="doc-backlink">Region of Interest</a><a class="headerlink" href="#region-of-interest" title="Link to this heading">¶</a></h4>
<p>The selection of the ROI is done the same way as in the <a class="reference internal" href="#automatedestimation"><span class="std std-ref">Automated Estimation</span></a>.
But additionally, three more figures are shown:</p>
<ul class="simple">
<li><p>The RMS values as a 3D image.</p></li>
<li><p>The MIP values as a 3D image.</p></li>
<li><p>The RMS values next to the created mask as a 3D image.</p></li>
</ul>
<p>The first two figures allow a closer inspection of the image.
This can be used to more precisely find the ROI and threshold values.
To get more precise values for the ROI, the MATLAB figure’s “Data Tips” tool can be used, while scrolling through the different views.
Alternatively, the left mouse button can be used to click on a pixel, which shows its coordinates in the title.</p>
<a class="reference internal image-reference" href="_images/setXmax.png"><img alt="Showing the max value of the x coordinates." class="align-center" src="_images/setXmax.png" style="width: 60%;" />
</a>
<p>To further inspect the threshold, MATLAB’s “Adjust Contrast Tool” can be used by pressing Ctrl + e.
By reducing the range of the allowed contrast, the image can be shown in a binary representation and a threshold value can be selected using the lower limit of the range.
Using Shift + e before changing the image allows to apply the adjusted contrast to the whole image and scrolling through it to observe the effect of the set threshold.</p>
<p>Here is an example:</p>
<a class="reference internal image-reference" href="_images/filtering.png"><img alt="Changing the contrast of the image." class="align-center" src="_images/filtering.png" style="width: 90%;" />
</a>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The view can be changed by pressing Ctrl + Shift + x , y or z.</p>
<p>Note that the coordinates shown change as well depending on the view.
They are not always reprented as (x, y, z), but depend on the axes shown.</p>
<p>By pressing the key “h”, the help information for the figure is written in the Matlab console.
This information explains all the possible options to manipulated the visualization of the data.</p>
</div>
<p>The third figure allows visual confirmation of the accuracy of the created mask.
Keep in mind that the goal of the tresholding is to remove as much noise as possible,
but to keep most of the information intact to achieve the best coil sensivity estimation.
The example shown, give you an idea of a correct thresholding, with most of the brain data mantained with only a small amount of residual noise in the corners, that will be filtered out by the bounding box selection.</p>
</section>
</section>
<section id="sensitivity-approximation">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Sensitivity Approximation</a><a class="headerlink" href="#sensitivity-approximation" title="Link to this heading">¶</a></h3>
<p>After the first estimation of the coil sensitivity, a heuretic gradient descent algorithm is applied to improve on this estimation.
This is done iteratively for a number of iterations that can be set in the script. For further explanation see <a class="reference internal" href="#improvedestimation">ImprovedEstimation</a>.</p>
<p>After each gradient descent step, an image is generated that shows the combined image using the coils. This can be used to control the effects of the gradient descent.</p>
</section>
</section>
<section id="code-explanation">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Code Explanation</a><a class="headerlink" href="#code-explanation" title="Link to this heading">¶</a></h2>
<p>This part goes into a bit more detail of the code, which allows to more easily modify the coil sensitivity estimation process.</p>
<section id="path-selection">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Path selection</a><a class="headerlink" href="#path-selection" title="Link to this heading">¶</a></h3>
<p>The script starts out by setting the two flags mentioned above. Afterwards the paths of the files and the destination folder are set.
These can be set directly in the scrip to skip the selection during execution.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">bodyCoilFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span>
<span class="n">arrayCoilFile</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span>

<span class="n">saveFolder</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[];</span>
</pre></div>
</div>
</section>
<section id="parameters">
<h3><a class="toc-backref" href="#id14" role="doc-backlink">Parameters</a><a class="headerlink" href="#parameters" title="Link to this heading">¶</a></h3>
<p>The acquisition parameters are then read out in the function call:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myMriAcquisition_node</span><span class="p">,</span><span class="w"> </span><span class="n">reconFoV</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">ISMRMRD_readParam</span><span class="p">(</span><span class="n">arrayCoilFile</span><span class="p">,</span><span class="w"> </span><span class="n">autoFlag</span><span class="p">);</span>
</pre></div>
</div>
<p>myMriAcquisition_node is an object of the class bmMriAcquisitionParam and is storing the acquisition parameters.
As this is the object used for the extraction of the data, this step can be skipped if the parameters are set manually:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">myMriAcquisition_node</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmMriAcquisitionParam</span><span class="p">([]);</span>
<span class="n">myMriAcquisition_node</span><span class="p">.</span><span class="n">N</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">128</span><span class="p">;</span>
<span class="k">...</span>
<span class="n">myMriAcquisition_node</span><span class="p">.</span><span class="n">FoV</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">240</span><span class="p">;</span>
<span class="n">reconFoV</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">240</span><span class="p">;</span>
</pre></div>
</div>
<p>The estimation is done on a low resolution image to improve the result. The grid, which defines the resolution is set at the end of the section.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">N_u</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[</span><span class="mi">48</span><span class="p">,</span><span class="w"> </span><span class="mi">48</span><span class="p">,</span><span class="w"> </span><span class="mi">48</span><span class="p">];</span>
</pre></div>
</div>
<p>This value can be changed to fit the user’s needs. Good values range from 48 to 96. A too high resolution reduces the signal to noise ratio and increases execution time drastically.</p>
</section>
<section id="data-extraction">
<h3><a class="toc-backref" href="#id15" role="doc-backlink">Data extraction</a><a class="headerlink" href="#data-extraction" title="Link to this heading">¶</a></h3>
<p>In the function <cite>bmCoilSense_nonCart_dataFromISMRMRD</cite>, the raw data is extracted, the trajectory is generated and the volume elements are computed.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">myMriAcquisition_node</span><span class="p">.</span><span class="n">nCh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">nCh_body</span><span class="p">;</span>
<span class="p">[</span><span class="n">y_body</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmCoilSense_nonCart_dataFromISMRMRD</span><span class="p">(</span>
<span class="w">                     </span><span class="n">bodyCoilFile</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                     </span><span class="n">N_u</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">                     </span><span class="n">myMriAcquisition_node</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both the trajectory and the volume element computation method have to be changed manually and the trajectory is not yet read out of the ISMRM raw data file.
Later on, the option to choose should be implemented in a gui element.</p>
</div>
<p>Within the function <cite>bmCoilSense_nonCart_dataFromTwix</cite>:</p>
<ul>
<li><p>The trajectory is generated using the function <cite>bmTraj_fullRadial3_phyllotaxis_lineAssym2</cite>.</p>
<blockquote>
<div><ul class="simple">
<li><p>Here, the use of a 3D phyllotaxis trajectory is assumed.</p></li>
<li><p>This function has to be changed for another if the trajectory required is different.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>The volume elements are computed using the function <cite>bmVolumeElement</cite>.</p>
<blockquote>
<div><ul class="simple">
<li><p>Different options are implemented for different types of trajectories and for different computation methods. The options are all listed in the documentation of the function. For example, in the following case, the voronoi algorithm is used to calculate the volume given a 3D radial trajectory (t).</p></li>
</ul>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">ve</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmVolumeElement</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="s">&#39;voronoi_full_radial3&#39;</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p>If none of the provided cases match the acquisition’s trajectory, a new volume element calculation function has to be defined.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Retain only the raw k-space data within a specified box (defined by N_u and the FoV).</p>
<blockquote>
<div><ul class="simple">
<li><p>This preserves the lower frequencies, removing any high frequency detail, resulting in a lower resolution.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>The same function is used once again to extract the raw data of the selected array coils.
The number of coils are updated to match the selected array coils.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">myMriAcquisition_node</span><span class="p">.</span><span class="n">nCh</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">nCh_array</span><span class="p">;</span>
<span class="n">y_array</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmCoilSense_nonCart_dataFromISMRMRD</span><span class="p">(</span>
<span class="w">            </span><span class="n">arrayCoilFile</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">            </span><span class="n">N_u</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">            </span><span class="n">myMriAcquisition_node</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="gridding-matrices">
<span id="id1"></span><h3><a class="toc-backref" href="#id16" role="doc-backlink">Gridding Matrices</a><a class="headerlink" href="#gridding-matrices" title="Link to this heading">¶</a></h3>
<p>The next step is computing the gridding matrices:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Gn</span><span class="p">,</span><span class="w"> </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmTraj2SparseMat</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">N_u</span><span class="p">,</span><span class="w"> </span><span class="n">dK_u</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, <cite>Gn</cite> and <cite>Gut</cite> perform the backward transformation (from non-Cartesian to Cartesian), while <cite>Gu</cite> performs the forward transformation (from Cartesian to non-Cartesian).</p>
</section>
<section id="id2">
<h3><a class="toc-backref" href="#id17" role="doc-backlink">Mask Creation</a><a class="headerlink" href="#id2" title="Link to this heading">¶</a></h3>
<p>The creation of the mask is done using two thresholds to exclude artifacts from regions without signals, such as air in the lungs, and a ROI selection to exlude artifacts outside the ROI.
This is particularly relevant for the center region of the coil sensitivity plot and is done in the function <cite>bmCoilSense_nonCart_mask_automatic</cite>.</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmCoilSense_nonCart_mask_automatic</span><span class="p">(</span><span class="n">y_body</span><span class="p">,</span><span class="w"> </span><span class="n">Gn</span><span class="p">,</span><span class="w"> </span><span class="n">autoFlag</span><span class="p">);</span>
</pre></div>
</div>
<p>The function also accepts predefined values for the thresholds and the ROI instead of deciding on them during the execution. See the function documentation for more information.</p>
</section>
<section id="coil-sensitivity-estimation">
<h3><a class="toc-backref" href="#id18" role="doc-backlink">Coil Sensitivity Estimation</a><a class="headerlink" href="#coil-sensitivity-estimation" title="Link to this heading">¶</a></h3>
<p>The first estimation is done using the following to functions:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">y_ref</span><span class="p">,</span><span class="w"> </span><span class="n">C_ref</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmCoilSense_nonCart_ref</span><span class="p">(</span><span class="n">y_body</span><span class="p">,</span><span class="w"> </span><span class="n">Gn</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="p">[]);</span>
<span class="n">C_array_prime</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmCoilSense_nonCart_primary</span><span class="p">(</span><span class="n">y_array</span><span class="p">,</span><span class="w"> </span><span class="n">y_ref</span><span class="p">,</span><span class="w"> </span><span class="n">C_ref</span><span class="p">,</span><span class="w"> </span><span class="n">Gn</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<p>Where the <cite>bmCoilSense_nonCart_ref</cite> function uses the body coils to create a reference coil sensitivity map, with the masked parts smoothed by solving the Laplace equation.
The output reference coil is always taken as the <strong>first</strong> body coil. To change this, the following lines have to be changed in the function:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">C_ref</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">C</span><span class="p">(:,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">y_ref</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">y</span><span class="p">(:,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>And the <cite>bmCoilSense_nonCart_primary</cite> function creates an initial estimation of the coil sensitivity for all surface coils.</p>
</section>
<section id="improved-estimation">
<span id="improvedestimation"></span><h3><a class="toc-backref" href="#id19" role="doc-backlink">Improved Estimation</a><a class="headerlink" href="#improved-estimation" title="Link to this heading">¶</a></h3>
<p>With the initial coil sensitivity <code class="docutils literal notranslate"><span class="pre">C_array_prime</span></code>, a better coil sensitivity is estimated using gradient descent in the function <cite>bmCoilSense_nonCart_secondary</cite>.
This process alternately updates the coil sensitivity map <code class="docutils literal notranslate"><span class="pre">C</span></code> and the reconstructed image <code class="docutils literal notranslate"><span class="pre">X</span></code> to solve <span class="math notranslate nohighlight">\(||FXC - y|| = 0\)</span>.
The coil sensitivity map of the reference coil remains unchanged to restrict the changes and not have <code class="docutils literal notranslate"><span class="pre">C</span></code> and <code class="docutils literal notranslate"><span class="pre">X</span></code> diverge.</p>
<p>How many iteration of the gradient descent should be performed can be set using <code class="docutils literal notranslate"><span class="pre">nIter</span></code>:</p>
<div class="highlight-matlab notranslate"><div class="highlight"><pre><span></span><span class="n">nIter</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">bmCoilSense_nonCart_secondary</span><span class="p">(</span>
<span class="w">            </span><span class="n">y_array</span><span class="p">,</span><span class="w"> </span><span class="n">C_array_prime</span><span class="p">,</span><span class="w"> </span><span class="n">y_ref</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">            </span><span class="n">C_ref</span><span class="p">,</span><span class="w"> </span><span class="n">Gn</span><span class="p">,</span><span class="w"> </span><span class="n">Gu</span><span class="p">,</span><span class="w"> </span><span class="n">Gut</span><span class="p">,</span><span class="w"> </span><span class="n">ve</span><span class="p">,</span><span class="w"> </span><span class="n">nIter</span><span class="p">,</span><span class="w"> </span><span class="k">...</span>
<span class="w">            </span><span class="o">~</span><span class="n">autoFlag</span><span class="p">);</span>
</pre></div>
</div>
<p>The coil sensitivity <code class="docutils literal notranslate"><span class="pre">C</span></code> is saved as a matrix in a MATLAB data file for the next step.
The code can be modified to save the reconstructed image <code class="docutils literal notranslate"><span class="pre">x</span></code> as well.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>  <!-- This includes the original document content -->

    <!-- Back to Top Button -->
    <button onclick="scrollToTop()" id="back-to-top" title="Go to top">↑</button>
  </div>

      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Monalisa</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="1_quick_start.html">Quick Start</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="2_contents.html">Contents</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="2-1_introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-2_reconstruction_calls.html">Reconstruction Calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-3_mitosius_prepare.html">The Mitosius</a></li>
<li class="toctree-l2"><a class="reference internal" href="2-4_binning_masks.html">Binning: Flexible Readout Rearrangement</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Coil Sensitivity Map Estimation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coil-sensitivity-from-pre-scan-images">Coil sensitivity from pre-scan images</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coil-sensitivity-from-raw-data-pre-scans">Coil sensitivity from raw data pre-scans</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automated-estimation">Automated Estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#manual-estimation">Manual Estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-explanation">Code Explanation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="2-6_prescan_acquisition.html">Acquisition Guidelines for Coil Sensitivity Estimation using Prescans</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="3_examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="4_api.html">API</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="5_docker.html">Docker for Monalisa</a></li>
<li class="toctree-l1"><a class="reference internal" href="6_ack_contribution.html">Acknowledgment and Authors</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="2_contents.html">Contents</a><ul>
      <li>Previous: <a href="2-4-4_binning_cardiac.html" title="previous chapter">Fourth Example: Cardiac Binning for Motion-Resolved Cardiac MRI using Superior-Inferior (SI) Projections</a></li>
      <li>Next: <a href="2-6_prescan_acquisition.html" title="next chapter">Acquisition Guidelines for Coil Sensitivity Estimation using Prescans</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Bastien Milani.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/2-5_coil_sensitivity_map.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>